---
content_type: page
description: This section provides the schedule of course topics, readings, and assignment
  due dates.
learning_resource_types:
- Readings
ocw_type: CourseSection
title: Calendar & Readings
uid: 87f29f92-0af6-3dd8-fa06-ba83153507b2
---

{{< tableopen >}}
{{< theadopen >}}
{{< tropen >}}
{{< thopen >}}
SES #
{{< thclose >}}
{{< thopen >}}
TOPICS
{{< thclose >}}
{{< thopen >}}
READINGS
{{< thclose >}}
{{< thopen >}}
KEY DATES
{{< thclose >}}

{{< trclose >}}

{{< theadclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 1: Intro to Functional Programming & Operational Semantics**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
1
{{< tdclose >}}
{{< tdopen >}}
Introduction to Functional Programming and Types
{{< tdclose >}}
{{< tdopen >}}


Some interesting reading about the genesis of functional programming:

Backus, John. "[Can Programming be Liberated from the Von Neumann Style? A Functional Style and its Algebra of Programs](http://dx.doi.org/10.1145/359576.359579)." _Magazine Communications of the ACM_ 8, no. 21 (1978): 613–41.

Hudak, Hughes, Peyton Jones, et al. ["A History of Haskell: Being Lazy With Class." (PDF)](https://www.microsoft.com/en-us/research/publication/a-history-of-haskell-being-lazy-with-class/) 2007.


{{< tdclose >}}
{{< tdopen >}}
Problem Set 1 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
2
{{< tdclose >}}
{{< tdopen >}}
Lambda Calculus
{{< tdclose >}}
{{< tdopen >}}


Suggested Reading:

[![Buy at MIT Press](/images/mp_logo.gif)](https://mitpress.mit.edu/9780262162098) Pierce, Benjamin C. Chapter 5 in _Types and Programming Languages_. MIT Press, 2002. ISBN: 9780262162098. \[Preview with [Google Books](http://books.google.com/books?id=ti6zoAC9Ph8C&pg=PA51=onepage)\]


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
3
{{< tdclose >}}
{{< tdopen >}}
Big-Step vs. Small-Step Semantics and the λLet Calculus
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
4
{{< tdclose >}}
{{< tdopen >}}
Coq Crash Course (Examples in Operational Semantics)
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 1 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 2: Type Theory**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
5
{{< tdclose >}}
{{< tdopen >}}
Introduction to Simple Types
{{< tdclose >}}
{{< tdopen >}}


[![Buy at MIT Press](/images/mp_logo.gif)](https://mitpress.mit.edu/9780262162098) Cardelli's, Luca. "Type Systems." In _Types and Programming Languages_. MIT Press, 2002. ISBN: 9780262162098.


{{< tdclose >}}
{{< tdopen >}}
Problem Set 2 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
6
{{< tdclose >}}
{{< tdopen >}}
Hindley-Milner Type Inference and Polymorphic Types
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
7
{{< tdclose >}}
{{< tdopen >}}
Algebraic Data Types & Their Ingredients: Product, Sum, and Recursive Types
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
8
{{< tdclose >}}
{{< tdopen >}}
Type Classes and Subtyping
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 3: Types for Imperative Programs**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
9
{{< tdclose >}}
{{< tdopen >}}
Monads
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}


Problem Set 2 due

Problem Set 3 Out


{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
10
{{< tdclose >}}
{{< tdopen >}}
Typing of Imperative Programs
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
11
{{< tdclose >}}
{{< tdopen >}}
Verification of Complex Properties with Types: From Information Flow to Race Detection
{{< tdclose >}}
{{< tdopen >}}


Myers, A. C. "[JFlow: Practical Mostly-static Information Flow Control](http://dx.doi.org/10.1145/292540.292561)." _Principles of Programming Languages_ (1999): 228–41.

Flanagan, C., and S. N. Freund. "[Type-based Race Detection for Java](http://dx.doi.org/10.1145/358438.349328)." _ACM SIGPLAN Notices_ 35, no. 5 (2000): 219–32.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 4: Axiomatic Semantics**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
12
{{< tdclose >}}
{{< tdopen >}}
Intro to Axiomatic Semantics
{{< tdclose >}}
{{< tdopen >}}


Floyd, Robert. ["Assigning Meanings to Programs." (PDF)](http://www.eecs.berkeley.edu/~necula/Papers/FloydMeaning.pdf)


{{< tdclose >}}
{{< tdopen >}}
Problem Set 4 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
13
{{< tdclose >}}
{{< tdopen >}}
Verification Condition Generation
{{< tdclose >}}
{{< tdopen >}}
Hoare. "[An Axiomatic Basis for Computer Programming](http://dx.doi.org/10.1145/363235.363259)." _Communications of the ACM_ 12, no. 10 (1969): 576–80.
{{< tdclose >}}
{{< tdopen >}}
Problem Set 3 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
14
{{< tdclose >}}
{{< tdopen >}}
Total Correctness and Termination
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
15
{{< tdclose >}}
{{< tdopen >}}
Separation Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
16
{{< tdclose >}}
{{< tdopen >}}
Axiomatic Semantics for Concurrency: Rely-Guarantee & Concurrent Separation Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 5: Abstract Interpretation**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
17
{{< tdclose >}}
{{< tdopen >}}
Dataflow Analysis, Lattices, Fixed Points
{{< tdclose >}}
{{< tdopen >}}
Kildall, Gary. "[A Unified Approach to Global Program Optimization](http://dx.doi.org/10.1145/512927.512945)." _Principles of Programming Languages_ (1973): 194–206.
{{< tdclose >}}
{{< tdopen >}}


Problem Set 4 due

Problem Set 5 Out


{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
18
{{< tdclose >}}
{{< tdopen >}}
Abstract Interpretation, Galois Connections
{{< tdclose >}}
{{< tdopen >}}
Cousot, P., and R. Cousot. "[Abstract Interpretation: A Unified Lattice Model for Static analysis of Programs by Construction or Approximation of Fixpoints](http://dx.doi.org/10.1145/512950.512973)." _Principles of Programming Languages_ (1977): 238–52.
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
19
{{< tdclose >}}
{{< tdopen >}}
Abstract Interpretation, Galois Connections (cont.)
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
20
{{< tdclose >}}
{{< tdopen >}}
The Heap: Inferring Loop Invariants About Data Structure Shape
{{< tdclose >}}
{{< tdopen >}}


Sagiv, Reps, et al. "[Solving Shape-Analysis Problems in Languages with Destructive Updating](http://dx.doi.org/10.1145/271510.271517)." _Principles of Programming Languages_ 20, no. 1 (1993): 1–50.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen colspan="4" >}}
**Unit 6: Model Checking**
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
21
{{< tdclose >}}
{{< tdopen >}}
Intro to Models and Properties
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
22
{{< tdclose >}}
{{< tdopen >}}
Temporal Logic
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 5 due
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
23
{{< tdclose >}}
{{< tdopen >}}
Explicit State Model Checking
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 6 Out
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
24
{{< tdclose >}}
{{< tdopen >}}
Symbolic Model Checking
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
25
{{< tdclose >}}
{{< tdopen >}}
Software Model Checking with Abstraction Refinement
{{< tdclose >}}
{{< tdopen >}}


Henzinger, T. A., R. Jhala, et al. "[Lazy Abstraction](http://dx.doi.org/10.1145/565816.503279)." _Principles of Programming Languages ACM_ 37, no. 1 (2002): 58–70.

Ball, T., R. Majumdar, et al. "[Automatic Predicate Abstraction of C Programs](http://web.cs.ucla.edu/~todd/research/pldi01.pdf)." _ACM SIGPLAN Notices_ 36, no. 5 (2001): 203–13.


{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}

{{< trclose >}}
{{< tropen >}}
{{< tdopen >}}
26
{{< tdclose >}}
{{< tdopen >}}
From Model Checking to Synthesis
{{< tdclose >}}
{{< tdopen >}}
 
{{< tdclose >}}
{{< tdopen >}}
Problem Set 6 due
{{< tdclose >}}

{{< trclose >}}

{{< tableclose >}}